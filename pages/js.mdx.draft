
## JavaScript

I’ll start by saying JavaScript is an interesting language: it “was developed in 5 days” as a way to add limited interactivity to documents, and has grown since then. It bears little resemblance to Java, and is instead based on the Ecmascript standard (an abstract spec for a scripting language implemented by JavaScript, as well as other, smaller scripting languages). Because of its rapid adoption and contortion from a small scripting language to a full-blown application framework, it certainly has its quirks; for a good highlight-reel of those quirks, check out [the WAT of JavaScript](https://www.destroyallsoftware.com/talks/wat).

Quirks aside, it is a full, turing-complete programming language. In fact, your browser has a full JavaScript REPL embedded in it: open up devtools and click on the “Console” tab and type:

```jsx
console.log("Hello, world!");
```

By clicking enter, the browser will evaluate that line and print “Hello, world!”. To take it a step further, you can copy the following to print your name! 

```jsx
const name = "YOUR NAME";
console.log("Hello, " + name + "!");
```

For a crash course on the syntax of JavaScript, check out the [Learn X in Y](https://learnxinyminutes.com/docs/javascript/). 

### The DOM

In the context of web pages, JavaScript is either included as a referenced file (same way CSS is included):

```jsx
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Demo app</title>
		**<script src="script.js" />**
  </head>
  <body>
    <p>Hello, world!</p>
  </body>
</html>
```

Or directly written inline:

```jsx
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Demo app</title>
		**<script>
			console.log("Hello, world!");
		</script>**
  </head>
  <body>
    <p>Hello, world!</p>
  </body>
</html>
```

In both cases, it is loaded along-side the webpage and provides hooks into browser’s in-memory model of the page, called the “document object model” or “DOM”, to listen for events and modify the page accordingly. By default, when the browser is parsing the HTML, if it encounters a script tag, it will stop, load the JavaScript, parse and then run the JavaScript before it resumes parsing the HTML. This is very rarely desired—as you almost always want to display SOMETHING to the user before you start loading a script—so you’ll either see script tags included at the bottom of the body (after the main content has been parsed and displayed) or with an async attribute (e.g. `<script src="..." async />`) which does the same thing.

Much like CSS, we can experiment with this using JSFiddle. For example, I can query for all the paragraph tags using: 

```jsx
console.log(document.querySelectorAll("p"));
```

And I can modify, or remove, those matching elements:

[https://jsfiddle.net/y43md1fq/4/](https://jsfiddle.net/y43md1fq/4/)

### Events

As I said before, every UI language needs a way to respond to user events. In JavaScript, this takes the form of explicit event listeners that you can attach. For example, I can add an event listener for click events:

[https://jsfiddle.net/09m4fvag/](https://jsfiddle.net/09m4fvag/)

Because components are nested, events may occur on multiple components: 

[https://jsfiddle.net/09m4fvag/1/](https://jsfiddle.net/09m4fvag/1/)

You may have noticed that the parent event happens AFTER the child event. For historical reasons, every node actually receives the event twice: once during the “capture” phase, and once during the “bubble” phase. In this case, events are received in the order:

1. Capture parent
2. Capture child
3. Bubble child
4. Bubble parent

Event listeners default to listening to the bubble event, but you can use their third parameter to convert them to listen to the capture event: 

[https://jsfiddle.net/09m4fvag/2/](https://jsfiddle.net/09m4fvag/2/)

By selecting the element in your browser’s developer tools, you can see any event handlers attached to it:

TODO: IMAGE

And if you go to the `source` panel, you can even set a breakpoint on it:

TODO: IMAGE

## Media

Beyond HTML, JS, and CSS, browsers can render and embed a variety of media files to make documents more rich. For example, they can handle a variety of images: 

- JPEG: Lossy image files
- PNG: Lossless image files
- WEBP: Google-optimized image files
- SVG: Vector files

They can also natively embed audio and video through MP4s. 

For file formats that browsers can’t natively read, the Canvas API lets the browser directly paint to the screen (using the same kind of imperative APIs you might find in a native application). As a result, developers have written libraries to add support for other file types. For example, HLS.js (TODO LINK) adds support for HLS, a format for streaming video not natively supported by browsers, by reading the format and rendering it through canvas.

# Chapter 2: JavaScript

All UI pretty much boils down to this:

1. Draw something on the screen
2. Listen to and react to user events (clicks, hovers, swipes, etc.) or global events (time changed, window resized, wifi disabled)

As an implementation detail, UIs are either defined:

1. Imperatively: draw this rectangle at these coordinates, now draw an exit button at these coordinates which are the top right of that rectangle; or
2. Declaratively: there will be a rectangle with an exit button in the top right

Different platforms pick between those two based on the use-case and the performance characteristics (for example, as a platform developer, you may not want people developing for your platform to be able to execute arbitrary code, in this case a declarative UI would be better suited to your needs).

—

With the building blocks of HTML, CSS, and JavaScript, the web changed very quickly: JavaScript didn’t stay a scripting language intended to open and close dropdowns for long; developers got increasingly ambitious with what web applications could do; and APIs were added to enable increasingly more native experiences; specifically: 

- XHR: enabling webpages to programmatically query the network for additional data
- HTML5: an updated specification for HTML, adding APIs targeted at full application development such as offline, history, geolocation, file reading, image rendering, etc.

For a full list of JavaScript APIs, check out [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript). 

## TK Shims and polyfills

Up until now, we haven’t really talked about the governance of the web. The web standard is officially maintained by the W3, a standalone group intended to govern the protocols of the web; however, in practice, it is frequently driven forward by the browser vendors who agree on APIs and start implementing them. 

Because of this decentralized governing and 

WHAT BEHAVIOR

A cross platform application engine isn’t without challenges; doubly so when there isn’t one vendor for the runtime. Every browser implements a subset

TODO: LINK TO CANIUSE

prototypes and this

RESET.css

## TK A quick history of frontend frameworks

Alongside the new APIs and browser-based applications (or perhaps powering the browser-based applications) came a suite of libraries 

## TK JSX: from JS-in-HTML to HTML-in-JS

FPS and render loops

## TK The universal virtual machine

People who really believe in the web platform will tell you it’s a full fledged virtual machine: a sandboxed render engine and scripting environment that runs on virtually every device. 

One technological arc to highlight are the people compiling traditionally native languages into JavaScript. 

 It started with ASM.js and Emscripten: ASM.js was a subset of JavaScript intended as a compile target, and Emscripten was a backend for LLVM (a very common compiler with support for C, C++, ObjC, etc.). Emscripten could compile native code into ASM.js and even render graphics APIs directly to the screen via Canvas (JavaScript’s realtime drawing APIs). 

This made for interesting technical demos, but became very real with WASM (or WebAssembly), a browser-supported compile target for the web that was (1) safe, and (2) directly transformable into native bytecode. This made it much faster than anything interpretted; some of the early benchmarks of WASM showed that it was only 2x slower than native! While the might seem like a high number, imagine being able to run PhotoShop in your browser with only 2x overhead compared running native… that’s really fast.

For something between satire and reality, [The Birth and Death of JavaScript](https://www.destroyallsoftware.com/talks/the-birth-and-death-of-javascript) is a funny talk intended to both show us what’s possible and make fun of where this could lead.

# Chapter 3: The “ecosystem”

Senior eng in JS in 2022

[https://www.youtube.com/watch?v=Uo3cL4nrGOk](https://www.youtube.com/watch?v=Uo3cL4nrGOk)

## TK Runtimes and dialects

## TK Languages, linters, and compilers

## TK Packagers and transpilers

## TK Package managers and libraries

## TK Orchestrators and Scaffolders

## TK Styling


We should talk around the event loop, and how JS is global single threaded (so you don't want to block the render loop with it)